# 进程间通信

## 进程通信常见方式

1. 管道：使用简单
2. 信号：开销比较小
3. 共享映射区：无血缘关系
4. 本地套接字：最稳定

### 管道

图示：



管道是一种最基本的 IPC 机制，作用于有血缘关系的进程之间，完成数据传递。调用 pipe 系统函数即可创建一 个管道。有如下特质:

1. 其本质是一个**伪文件**(实为内核缓冲区)
2. 由两个文件描述符引用，一个表示读端，一个表示写端。
3. 规定数据从管道的写端流入管道，从读端流出。

管道的原理: 管道实为内核使用**环形队列机制**，借助内核缓冲区(4k)实现。

管道的局限性:

1. 数据不能进程自己写，自己读。
2. 管道中数据不可反复读取。一旦读走，管道中不再存在。
3. 采用半双工通信方式，数据只能在单方向上流动。
4. 只有有血缘关系的才能通信

### pipe函数

创建并打开管道，函数原型：

```c
int pipe(int fd[2]);
fd[0]: read
fd[1]: write
```

一个管道通信的示例，父进程往管道里写，子进程从管道读，然后打印读取的内容：

![Screen Shot 2021-12-25 at 20.13.45](/Users/fszhuangb/Library/Application Support/typora-user-images/Screen Shot 2021-12-25 at 20.13.45.png)

问题：能否保证父进程写完了子进程才读？

### 管道读写行为

1. 读管道
   1. 有数据：返回实际读到的字节数。
   2. 无数据：
      - 管道写端被关闭，返回0
      - 写端未关闭，阻塞等待
2. 写管道
   1. 读端被关闭（没有进程把持），异常终止，返回SIGPIPE信号
   2. 管道读端没有全部关闭:
      - buffer空间够，即管道未满
      - buffer空间不够，管道已满，阻塞等待

练习:使用管道实现父子进程间通信，完成:`ls | wc -l`。假定父进程实现 ls，子进程实现 wc。

ls 命令正常会将结果集写出到 stdout，但现在会写入管道的写端;wc –l 正常应该从 stdin 读取数据，但 此时会从管道的读端读。